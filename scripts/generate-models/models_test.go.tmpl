// Code generated by groq-modeler DO NOT EDIT.
//
// Created at: {{ getCurrentDate }}
//
// groq-modeler Version 1.1.2
package models_test

import (
	"bytes"
	"context"
	"os"
	"testing"
	"time"

	"github.com/conneroisu/groq-go"
	"github.com/conneroisu/groq-go/pkg/models"
	"github.com/conneroisu/groq-go/pkg/moderation"
	"github.com/conneroisu/groq-go/pkg/test"
	"github.com/stretchr/testify/assert"

	_ "embed"
)

//go:embed testdata/whisper.mp3
var whisperBytes []byte

{{- range $model := .ChatModels }}
// TestChatModels{{ $model.Name }} tests the {{ $model.Name }} model.
//
// It ensures that the model is supported by the groq-go library and the groq 
// API. // and the operations are working as expected for the specific model type.
func TestChatModels{{ $model.Name }}(t *testing.T) {
	if len(os.Getenv("UNIT")) < 1 {
		t.Skip("Skipping {{ $model.Name }} test")
	}
	a := assert.New(t)
	ctx := context.Background()
	apiKey, err := test.GetAPIKey("GROQ_KEY")
	a.NoError(err, "GetAPIKey error")
	client, err := groq.NewClient(apiKey)
	a.NoError(err, "NewClient error")
	response, err := client.CreateChatCompletion(ctx, groq.ChatCompletionRequest{
		Model: models.Model{{ $model.Name }},
		Messages: []groq.ChatCompletionMessage{
			{
				Role:    groq.ChatMessageRoleUser,
				Content: "What is a proface display?",
			},
		},
		MaxTokens: 10,
		RetryDelay: time.Second * 2,
	})
	a.NoError(err, "CreateChatCompletionJSON error")
	if len(response.Choices[0].Message.Content) == 0 {
		t.Errorf("response.Choices[0].Message.Content is empty for model {{ $model.Name }} calling CreateChatCompletion")
	}
}
{{- end }}

{{- range $model := .TranscriptionModels }}
// Test{{ $model.Name }} tests the {{ $model.Name }}  transcription model.
//
// It ensures that the model is supported by the groq-go library, the groq API,
// and the operations are working as expected with the api call using this transcription 
// model.
func Test{{ $model.Name }}(t *testing.T) {
	if len(os.Getenv("UNIT")) < 1 {
		t.Skip("Skipping {{ $model.Name }} transcription test")
	}
	time.Sleep(time.Second * 5)
	a := assert.New(t)
	ctx := context.Background()
	apiKey, err := test.GetAPIKey("GROQ_KEY")
	a.NoError(err, "GetAPIKey error")
	client, err := groq.NewClient(apiKey)
	a.NoError(err, "NewClient error")
	reader := bytes.NewReader(whisperBytes)
	response, err := client.CreateTranscription(ctx, groq.AudioRequest{
		Model:    models.ModelWhisperLargeV3,
		Reader:   reader,
		FilePath: "whisper.mp3",
	})
	a.NoError(err, "CreateTranscription error")
	a.NotEmpty(response.Text, "response.Text is empty for model WhisperLargeV3 calling CreateTranscription")
}
{{- end }}

{{- range $model := .ModerationModels }}
// Test{{ $model.Name }} tests the {{ $model.Name }} model.
//
// It ensures that the model is supported by the groq-go library, the groq API,
// and the operations are working as expected for the specific model type.
func Test{{ $model.Name }}(t *testing.T) {
	if len(os.Getenv("UNIT")) < 1 {
		t.Skip("Skipping {{ $model.Name }} moderation test")
	}
	time.Sleep(time.Second * 5)
	a := assert.New(t)
	ctx := context.Background()
	apiKey, err := test.GetAPIKey("GROQ_KEY")
	a.NoError(err, "GetAPIKey error")
	client, err := groq.NewClient(apiKey)
	a.NoError(err, "NewClient error")
	response, err := client.Moderate(ctx, 
		[]groq.ChatCompletionMessage{
			{
				Role:    groq.ChatMessageRoleUser,
				Content: "I want to kill them.",
			},
		},
		models.Model{{ $model.Name }},
	)
	a.NoError(err, "Moderation error")
	a.Equal(true, response.Flagged)
	a.Contains(
		response.Categories,
		moderation.CategoryViolentCrimes,
	)
}
{{- end }}

{{- range $model := .MultiModalModels }}
// Test{{ $model.Name }} tests the {{ $model.Name }} model.
//
// It ensures that the model is supported by the groq-go library, the groq API,
// and the operations are working as expected for the specific model type.
func Test{{ $model.Name }}(t *testing.T) {
}
{{- end }}
